{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport { web3 } from '../web3';\nvar registry = new web3.eth.Contract(require('../chain/Registry.json'), require('../chain/Registry.js'));\nexport var LOAD_ENTRY_PROGRESS = 'LOAD_ENTRY_PROGRESS';\nexport var LOAD_ENTRY_COMPLETE = 'LOAD_ENTRY_COMPLETE';\nexport function loadEntry(title) {\n  // registry.lookup(key) => entryId[]\n  // entryId is stored offchain but let's store everything onchain for now\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(dispatch) {\n        var key, evs, results;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                dispatch({\n                  type: LOAD_ENTRY_PROGRESS,\n                  title: title\n                });\n                key = web3.utils.keccak256(title); // debugger\n\n                console.log(key);\n                _context.next = 5;\n                return registry.getPastEvents('Put', {\n                  filter: {\n                    key: key\n                  },\n                  fromBlock: '0',\n                  toBlock: 'latest'\n                });\n\n              case 5:\n                evs = _context.sent;\n                results = evs.map(function (ev) {\n                  var _ev$returnValues = ev.returnValues,\n                      url = _ev$returnValues.url,\n                      creator = _ev$returnValues.creator,\n                      key = _ev$returnValues.key,\n                      time = _ev$returnValues.time;\n                  dispatch(loadUserInfo(creator));\n                  return {\n                    url: url,\n                    creatorId: creator.toString(),\n                    key: key,\n                    total: 0,\n                    time: time.toNumber()\n                  };\n                });\n                dispatch(loadEntryComplete(results));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n}\n\nfunction loadEntryComplete(results) {\n  return {\n    type: LOAD_ENTRY_COMPLETE,\n    results: results\n  };\n}\n\nexport var LOAD_NEWEST_ENTRIES_COMPLETE = 'LOAD_NEWEST_ENTRIES_COMPLETE';\nexport function loadNewestEntries() {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(dispatch) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }()\n  );\n}\n\nfunction sortEntries(entries) {// sort by the EBSL weighted whatever\n  // just load a big matrix, and cache it offline for later\n  // but we have to load all trust relations\n  // make a fucckton of calls to the chain\n  // which is probably why it's best to update this matrix on chain from time to time \n  // so we can just call it and the node's already know\n}\n\nimport { trackTx } from './txs';\nimport { loadUserInfo } from './users';\nexport var ADD_TO_REGISTRY_PROGRESS = 'ADD_TO_REGISTRY_PROGRESS';\nexport function addToRegistry(userId, title, url) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(dispatch) {\n        var accounts, ev;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                dispatch({\n                  type: ADD_TO_REGISTRY_PROGRESS,\n                  txhash: null\n                });\n                _context3.next = 3;\n                return web3.eth.getAccounts();\n\n              case 3:\n                accounts = _context3.sent;\n                ev = registry.methods.put(userId, title, url).send({\n                  from: accounts[0]\n                });\n                ev.on('transactionHash', function (txhash) {\n                  dispatch({\n                    type: ADD_TO_REGISTRY_PROGRESS,\n                    txhash: txhash\n                  });\n                  dispatch(trackTx(ev, txhash));\n                });\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }()\n  );\n}","map":{"version":3,"sources":["/Users/liamz/Documents/open-source/everest/social/actions/registry.js"],"names":["web3","registry","eth","Contract","require","LOAD_ENTRY_PROGRESS","LOAD_ENTRY_COMPLETE","loadEntry","title","dispatch","type","key","utils","keccak256","console","log","getPastEvents","filter","fromBlock","toBlock","evs","results","map","ev","returnValues","url","creator","time","loadUserInfo","creatorId","toString","total","toNumber","loadEntryComplete","LOAD_NEWEST_ENTRIES_COMPLETE","loadNewestEntries","sortEntries","entries","trackTx","ADD_TO_REGISTRY_PROGRESS","addToRegistry","userId","txhash","getAccounts","accounts","methods","put","send","from","on"],"mappings":"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","sourcesContent":["import { web3 } from '../web3'\n\nconst registry = new web3.eth.Contract(\n    require('../chain/Registry.json'),\n    require('../chain/Registry.js')\n)\n\nexport const LOAD_ENTRY_PROGRESS = 'LOAD_ENTRY_PROGRESS'\nexport const LOAD_ENTRY_COMPLETE = 'LOAD_ENTRY_COMPLETE'\n\nexport function loadEntry(title) {\n    // registry.lookup(key) => entryId[]\n    // entryId is stored offchain but let's store everything onchain for now\n    \n    return async (dispatch) => {\n        dispatch({\n            type: LOAD_ENTRY_PROGRESS,\n            title\n        })\n\n        const key = web3.utils.keccak256(title)\n        // debugger\n\n        console.log(key)\n        let evs = await registry.getPastEvents(\n            'Put',\n            {\n                filter: {\n                    key\n                },\n                fromBlock: '0',\n                toBlock: 'latest'\n            }\n        )\n\n        const results = evs.map(ev => {\n            const { url, creator, key, time } = ev.returnValues;\n            \n            dispatch(loadUserInfo(creator))\n\n            return { \n                url, \n                creatorId: creator.toString(), \n                key, total: 0, time: time.toNumber() \n            }\n        })\n\n\n        dispatch(loadEntryComplete(results))\n    }    \n}\n\n\nfunction loadEntryComplete(results) {\n    return {\n        type: LOAD_ENTRY_COMPLETE,\n        results,\n    }\n}\n\nexport const LOAD_NEWEST_ENTRIES_COMPLETE = 'LOAD_NEWEST_ENTRIES_COMPLETE'\n\nexport function loadNewestEntries() {\n    return async dispatch => {\n        // Ethereum don't support no goddamn string params in events!!!\n\n        // let evs = await registry.getPastEvents(\n        //     'NewEntry',\n        //     {\n        //         fromBlock: '0',\n        //         toBlock: 'latest'\n        //     }\n        // )\n\n        // const results = evs.map(ev => {\n        //     return ev.returnValues.title\n        // })\n\n        // dispatch({\n        //     type: LOAD_NEWEST_ENTRIES_COMPLETE,\n        //     results\n        // })\n    }\n}\n\nfunction sortEntries(entries) {\n    // sort by the EBSL weighted whatever\n    // just load a big matrix, and cache it offline for later\n    // but we have to load all trust relations\n    // make a fucckton of calls to the chain\n\n    // which is probably why it's best to update this matrix on chain from time to time \n    // so we can just call it and the node's already know\n    \n}\n\nimport { trackTx } from './txs'\nimport { loadUserInfo } from './users';\n\nexport const ADD_TO_REGISTRY_PROGRESS = 'ADD_TO_REGISTRY_PROGRESS'\n\nexport function addToRegistry(userId, title, url) {\n    return async (dispatch) => {\n        dispatch({\n            type: ADD_TO_REGISTRY_PROGRESS,\n            txhash: null\n        })\n\n        const accounts = await web3.eth.getAccounts()\n        let ev = registry.methods.put(userId, title, url).send({ from: accounts[0] })\n\n        ev.on('transactionHash', txhash => {\n            dispatch({\n                type: ADD_TO_REGISTRY_PROGRESS,\n                txhash\n            })\n            \n            dispatch(trackTx(ev, txhash))\n        })        \n    }\n}"]},"metadata":{},"sourceType":"module"}